package robombs.game.model;

import robombs.game.view.*;

import com.threed.jpct.*;

/**
 * The base class for any kind of object in the game world. A LocalObject can exist on the server as well as on
 * the client. It contains everything needed to describe an object but doesn't represent the actual (3D-) view of it.
 */
public class LocalObject {

    // ID is negative: Generated by the server
    // ID is positive: Generated by the client
    private static int lid=-1000;

    private SimpleVector pos=null;
    private Matrix rot=null;
    private SimpleVector spd=null;
    protected int cid=0;
    private int objID=0;
    private int type=0;
    private int animation=Animations.NONE;
    private int animSpeed=0;
    private ClientObject view;
    private boolean collided=false;
    private int value=100;
    private long special=0;
    private long localTime=0;
    private boolean invincible=false;
    
    private boolean isDisabled=false; // Client only ATM
    
    /**
     * Create a new local object. Is is used to create new objects on the server that are not triggered
     * by the client.
     */
    public LocalObject() {
        objID=lid--;
        if (lid<-2147483640) {
            // To handle the wrap around...this should never happen, but...:-)
            lid=-1000;
        }
    }
    
    public LocalObject(int clientID, boolean hull) {
    	if (!hull) {
	        objID=lid--;
	        if (lid<-2147483640) {
	            // To handle the wrap around...this should never happen, but...:-)
	            lid=-1000;
	        }
    	}
    	cid = clientID;
    }

    /**
     * Create a new local object for that client. This is used to create objects for a specific client.
     * This can happen on the server as well as on a client.
     * @param clientID the unique ID of that client to which this object belongs
     */
    public LocalObject(int clientID) {
    	this();
        cid = clientID;
    }

    /**
     * Add a number to the objects value. What this value represents in the actual game context is up to
     * the implementation of the game. Without any given context, it's simply a generic value.
     * @param val the value that has to be added
     */
    public void addToValue(int val) {
        value+=val;
    }
    
    public boolean isDisabled() {
		return isDisabled;
	}
	
	public void disable() {
		isDisabled=true;
	}

    /**
     * Returns the value of this object. What this value represents in the actual game context is up to
     * the implementation of the game. Without any given context, it's simply a generic value.
     * @return int
     */
    public int getValue() {
        return value;
    }
    
    /**
     * Sets the objects value. What this value represents in the actual game context is up to
     * the implementation of the game. Without any given context, it's simply a generic value.
     * @param val the value
     */
    public void setValue(int val) {
        value=val;
    }

    public void setSpecialValue(long val) {
    	special=val;
    }
    
    public long getSpecialValue() {
    	return special;
    }
    
    /**
     * Wird nicht übertragen!
     * @param time
     */
    public void setLocalTimeStamp(long time) {
    	localTime=time;
    }
    
    /**
     * Wird nicht übertragen!
     * @param time
     */
    public long getLocalTimeStamp() {
    	return localTime;
    }
    
    /**
     * Set a flag that this object was part of a collision (like when a bullet hits a target).
     * @param has collided?
     */
    public void setCollided(boolean has) {
        collided = has;
    }

    /**
     * Returns if this object has collided with another one.
     * @return boolean true or false
     */
    public boolean hasCollided() {
        return collided;
    }

    /**
     * Copies the data from another local object to this one. This is used to copy the transfered state of a remote
     * object to the corresponding local object.
     * @param src the source object
     */
    public void copyFrom(LocalObject src) {
        this.view=src.getView();
        this.cid=src.getClientID();
        this.objID=src.getObjectID();
        this.animation=src.getAnimation();
        this.animSpeed=src.getAnimationSpeed();
        this.type=src.getType();
        this.rot=src.getRotation();
        this.spd=src.getSpeed();
        this.pos=src.getPosition();
        this.value=src.getValue();
        this.special=src.getSpecialValue();
        this.invincible=src.isInvincible();
    }

    /**
     * Sets the view for this local object. On the server, there is no view. The coupling between model and view is done here.
     * It's not very loose, because ClientObject is always a 3D-object. It doesn't matter in this example, but if you want to write
     * a 2D client ;-), you'll have to improve this.
     * @param obj the view object
     */
    public void setView(ClientObject obj) {
    	// This creates a cyclic reference. The collision listeners need this to get access to the model...not good...
        this.view=obj;
        obj.setModel(this);
    }

    /**
     * Returns the view object.
     * @return ClientObject the view object
     */
    public ClientObject getView() {
        return view;
    }

    /**
     * Sets the animation. This is a constant from Animations. It's just a number. It doesn't imply an actual animation. How the view
     * reacts to this value is up to it.
     * @param anim the animation
     */
    public void setAnimation(int anim) {
        animation=anim;
        if (anim==Animations.DEAD) {
        	// Dead? Don't move...
        	setSpeed(new SimpleVector());
        }
    }

    /**
     * Returns the animation.
     * @return int the animation
     */
    public int getAnimation() {
        return animation;
    }

    /**
     * Sets the speed of the animation.
     * @param speed the speed
     */
    public void setAnimationSpeed(int speed) {
        animSpeed = speed;
    }

    /**
     * Returns the speed of the animation.
     * @return int the speed
     */
    public int getAnimationSpeed() {
        return animSpeed;
    }

    /**
     * Sets the type of this object. The type is a number, usually taken from a constant in ClientObjectFactory, like
     * PLAYER or BULLET.
     * @param type the type
     */
    public void setType(int type) {
        this.type=type;
    }

    /**
     * Gets the type.
     * @return int the type
     */
    public int getType() {
        return type;
    }

    /**
     * Returns the client ID of this object. It has one, if it has been initialy created on a client even if it's a
     * representation of a remote object.
     * @return int the ID
     */
    public int getClientID() {
        return cid;
    }

    /**
     * Sets the object id. This usually is the ID of the view object for this local object.
     * @param oid the object ID
     */
    public void setObjectID(int oid) {
        this.objID=oid;
    }

    /**
     * Gets the object ID.
     * @return int the ID
     */
    public int getObjectID() {
        return objID;
    }

    /**
     * Sets the current position of the object.
     * @param pos the position
     */
    public void setPosition(SimpleVector pos) {
        this.pos=pos;
    }

    /**
     * Returns the current positoin of the object.
     * @return SimpleVector the position
     */
    public SimpleVector getPosition() {
        return pos;
    }

    /**
     * Sets the current rotation for this object, i.e. its direction.
     * @param mat the rotation matrix
     */
    public void setRotation(Matrix mat) {
        rot=mat;
    }

    /**
     * Returns the current rotation matrix.
     * @return Matrix the rotation
     */
    public Matrix getRotation() {
        return rot;
    }

    /**
     * Sets the "speed" of the object, i.e. the direction and speed in which it's moving.
     * @param spd the speed
     */
    public void setSpeed(SimpleVector spd) {
        this.spd=spd;
    }

    /**
     * Returns a vector indicating the direction/speed of this object's current movement.
     * @return SimpleVector the speed
     */
    public SimpleVector getSpeed() {
        return spd;
    }

    public boolean equals(Object obj) {
        if (obj instanceof LocalObject) {
            LocalObject lo = (LocalObject) obj;
            return this.cid == lo.getClientID() && this.objID == lo.getObjectID();
        }
        return false;
    }

    public int hashCode() {
        return cid + objID;
    }
    
    public void setInvincible(boolean inv) {
    	invincible=inv;
    }
    
    public boolean isInvincible() {
    	return invincible;
    }
}
